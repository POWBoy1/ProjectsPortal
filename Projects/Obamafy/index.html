<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Obamafy</title>
<link rel="icon" href="icon.png" type="image/png">

<style>
body {
  background:#111;
  color:#fff;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  height:100vh;
  margin:0;
  font-family:sans-serif;
}

h1 { margin-bottom:16px; }

input, button {
  margin-bottom:12px;
  padding:6px 12px;
  font-size:16px;
  cursor:pointer;
}

canvas {
  border:2px solid #fff;
  image-rendering: pixelated;
}
</style>
</head>
<body>

<h1>Obamafy</h1>
<input type="file" id="upload" accept="image/*">
<button id="startBtn">Start</button>
<canvas id="canvas" width="150" height="150"></canvas>

<script>
const upload = document.getElementById("upload");
const startBtn = document.getElementById("startBtn");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const W = canvas.width;
const H = canvas.height;

const PIXEL_SIZE = 1;

// ðŸ”§ Animation tuning
const SPREAD_TIME = 55;
const BASE_SPEED = 0.04;
const FAST_SPEED = 0.2;
const NOISE = 0.8;       // randomness
const CLUMP_FORCE = 0.6; // higher = more cramping

let sourcePixels = [];
let targetPixels = [];
let assignments = [];
let animating = false;
let frame = 0;

// Target image
const obamaImg = new Image();
obamaImg.src = "icon.png";
obamaImg.crossOrigin = "anonymous";

// Helpers
function brightness(r,g,b){
  return 0.2126*r + 0.7152*g + 0.0722*b;
}

function rand(min,max){
  return Math.random()*(max-min)+min;
}

function easeOut(t){
  return 1 - Math.pow(1 - t, 3);
}

// Load target pixels
obamaImg.onload = ()=>{
  const c = document.createElement("canvas");
  c.width = W;
  c.height = H;
  const cx = c.getContext("2d");
  cx.drawImage(obamaImg,0,0,W,H);
  const d = cx.getImageData(0,0,W,H).data;

  targetPixels = [];
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      const i=(y*W+x)*4;
      if(d[i+3]>0){
        targetPixels.push({
          x, y,
          b:brightness(d[i],d[i+1],d[i+2])
        });
      }
    }
  }
};

// Upload source
upload.addEventListener("change", e=>{
  animating=false;
  sourcePixels=[];
  assignments=[];
  ctx.clearRect(0,0,W,H);

  const file=e.target.files[0];
  if(!file) return;

  const reader=new FileReader();
  reader.onload=ev=>{
    const img=new Image();
    img.src=ev.target.result;
    img.onload=()=>{
      ctx.drawImage(img,0,0,W,H);
      const d=ctx.getImageData(0,0,W,H).data;

      for(let y=0;y<H;y++){
        for(let x=0;x<W;x++){
          const i=(y*W+x)*4;
          sourcePixels.push({
            color:[d[i],d[i+1],d[i+2]],
            b:brightness(d[i],d[i+1],d[i+2]),
            x:x,
            y:y
          });
        }
      }
    };
  };
  reader.readAsDataURL(file);
});

// Assign pixels
function assignPixels(){
  assignments=[];
  frame=0;

  const src=[...sourcePixels].sort((a,b)=>a.b-b.b);
  const tgt=[...targetPixels].sort((a,b)=>a.b-b.b);
  const count=Math.min(src.length,tgt.length);

  for(let i=0;i<count;i++){
    assignments.push({
      x: src[i].x,
      y: src[i].y,
      ox: src[i].x,
      oy: src[i].y,
      vx: rand(-1,1),
      vy: rand(-1,1),
      chaos: rand(0.3,1.2),
      tx: tgt[i].x,
      ty: tgt[i].y,
      color: src[i].color
    });
  }
}

// Animate
function animate(){
  if(!animating) return;
  ctx.clearRect(0,0,W,H);
  frame++;

  const cx=W/2, cy=H/2;

  for(const p of assignments){
    if(frame < SPREAD_TIME){
      // ðŸŸ¢ Random spread + clumping
      const t = easeOut(frame / SPREAD_TIME);

      // random drift
      p.x += p.vx * p.chaos * NOISE;
      p.y += p.vy * p.chaos * NOISE;

      // clump pull toward center
      p.x += (cx - p.x) * CLUMP_FORCE * 0.01 * t;
      p.y += (cy - p.y) * CLUMP_FORCE * 0.01 * t;

    } else {
      // ðŸ”¥ Strong attraction to target
      const t = Math.min(1,(frame-SPREAD_TIME)/35);
      const speed = BASE_SPEED + t*(FAST_SPEED-BASE_SPEED);

      p.x += (p.tx - p.x) * speed;
      p.y += (p.ty - p.y) * speed;
    }

    ctx.fillStyle=`rgb(${p.color[0]},${p.color[1]},${p.color[2]})`;
    ctx.fillRect(
      Math.round(p.x),
      Math.round(p.y),
      PIXEL_SIZE,
      PIXEL_SIZE
    );
  }

  requestAnimationFrame(animate);
}

// Start
startBtn.onclick=()=>{
  if(!sourcePixels.length || !targetPixels.length) return;
  assignPixels();
  animating=true;
  requestAnimationFrame(animate);
};
</script>

</body>
</html>
